Battlecode (MIT 6.470) package manager.

USAGE

1. Make sure you're using the latest tool version.

   bcpm self

2. Install the Battlecode distribution. Later, use the same command to update the distribution.

   bcpm dist

3a. Install the test suite.  Later, use the same command to update the suite.

   bcpm suite

After executing the commands above, import the project into Eclipse
(File > Import > Existing Projects into Workspace).
   
4a. Check out a player repository and set it up for development.

   cd ~/workspace  # Your Eclipse workspace.
   bcpm install git@git.pwnb.us:six370/yield.git

You'll need to import the project into Eclipse.

3b. Create a blank player.

   bcpm new team050
   
4b. Create a blank test suite.

   bcpm newsuite tests team050
   
If you go this route, you will have to create the git repositories yourself, and push them.

5. Run the tests against the player.

    bcpm test yield
    bcpm test git@git.pwnb.us:six370/yield.git

6. Run a single test case against the player.

    bcpm case yield win_vs_yield
    bcpm case git@git.pwnb.us:six370/yield.git win_vs_yield
    
    # The following commands run the first match right away, for maximum iterating speed.
    bcpm livecase yield win_vs_yield
    bcpm livecase git@git.pwnb.us:six370/yield.git win_vs_yield

7. Run a game against some other player code.

    bcpm match yield team000 venice

8. Remove the installed player. (removing the project folder is not enough!)

    bcpm uninstall yield
    
9. Create a new player from an existing template.

   bcpm copy myplayer git@git.pwnb.us:six370/yield.git

You'll need to import the project into Eclipse, and setup a git repository for the player.


TEST SUITES

The test suite must have its Java code structured just like the player (one package under 'src'),
and the recommended package name is 'test'. It must have a 'bcpm.yml' containing the name of the
player that the tests are written against, structured as follows.

    ---
    :target_player: team989

The actual tests are .rb (Ruby) files in the 'suite' directory. The following example showcases the
functionality available in a test suite. The suite DSL slightly resembles rspec.

    # Set the opponent for future matches.
    vs 'yield'
    
    # Set the map for future matches.
    map 'venice'
    
    # Disable energon draining.
    option 'bc.engine.upkeep', false
    
    # Replace a .java file in the player under test with a .java file in the test suite. 
    replace_class 'team989.RobotPlayer', 'test.players.RobotPlayer'
    
    # Add a .java file in the test suite to the player under test.
    add_class 'team989.LoggingStubs', 'test.stubs.LoggingStubs'
    
    # Re-route all calls that look like target.canMove(...) to
    # team989.LoggingStubs.canMoveStub(target, ...)
    stub_call 'canMove', 'team989.LoggingStubs.canMoveStub'
    
    # Replace the code marked with Stubs.canMove.logo in team989.LoggingStubs with the code marked
    # Stubs.canMove.logoSource in test.stubs.LoggingStubs
    #
    # Note that team989.LoggingStubs was created by an earlier add_class directive.
    replace_code 'team989.LoggingStubs', 'Stubs.canMove.logo',
                 'test.stubs.LoggingStubs', 'Stubs.canMove.logoSource'
    
    # Run a test match to check some conditions.
    match do
      it 'must win in any way' do
        should_win
      end
    
      it "shouldn't leak exceptions" do
        should_not_throw
      end
      
      it 'should fail' do
        fail
      end
    end
    
    # Reset energon draining option to its default value.
    option 'bc.engine.upkeep', nil

To prevent infinite recursion, stubbing should be disabled in the actual stubs. The stub
implementation below demonstrates the syntax for stubbing and code replacement.

    package test.stubs;
    
    import battlecode.common.Direction;
    import battlecode.common.RobotController;
    
    public class LoggingStubs {
      //$ -stubs
      public static final boolean canMoveStub(RobotController target, Direction where) {
        boolean returnValue = target.canMove(where);
        //$ +mark: Stubs.canMove.logo
        System.out.println("This should not show up");
        //$ -mark: Stubs.canMove.logo    
        System.out.println("canMove(" + where.toString() + ") -> " + returnValue);
        return returnValue;
      }
      //$ +stubs
    
      public static void markTest() {
        //$ +mark: Stubs.canMove.logoSource
        System.out.println("This should show up");
        //$ -mark: Stubs.canMove.logoSource
      }
    }

The code patching directives use very simple implementations based on file copying and regular
expressions. Following these best practices should help avoid broken builds:

  * Use Eclipse's "Organize imports" feature to achieve the item below:
  * Class names should be unqualified, and imports should use fully qualified names.
  * A test class should only depend on player code. E.g., move shared test code in team???.tests.
  * Use the same class name (but different package names) in add_class and replace_class.


INSTALLATION

On Ubuntu:
   
    sudo apt-get install ruby-full rubygems
    sudo gem install rubygems-update
    sudo `gem env | grep 'EXECUTABLE DIRECTORY' | ruby -e "puts gets.split(': ', 2).last"`/update_rubygems

On OSX:

   Get git from http://code.google.com/p/git-osx-installer/

On Windows 7+:

   Get git from http://code.google.com/p/msysgit/downloads/
   Get ruby 1.8.7 (add it to your path) from http://rubyinstaller.org/downloads/
   Get ant from http://code.google.com/p/winant/

On everything (skip the 'sudo' prefix on Windows though):

    sudo gem install rake echoe
    git clone git@git.pwnb.us:six370/bcpm.git
    cd bcpm
    rake install

You'll need an administrative shell on Windows.
