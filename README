Battlecode (MIT 6.470) package manager.

USAGE

1. Make sure you're using the latest tool version.

    bcpm self

2. Install the Battlecode distribution. Later, use the same command to update the distribution.

    bcpm dist

3a. Check out a player repository and set it up for development.

    cd ~/workspace  # Your Eclipse workspace.
    bcpm install git@git.pwnb.us:six370/yield.git

After executing the commands above, import the project into Eclipse
(File > Import > Existing Projects into Workspace).

3b. Create a blank player.

    bcpm new team1337
     
If you go this route, you will have to create the git repositories yourself, and push them.

4. Run the player's test suite.

    bcpm test yield

5. Run a single test case in the player's test suite.

    bcpm case yield win_vs_yield
    
    # The following command runs the first match right away, for maximum iterating speed.
    bcpm livecase yield win_vs_yield

6. Replay the last match ran in a test.

    bcpm replay

7. Run a game against some other player code.

    bcpm match yield team000 venice

    # The following command runs the match right away, for maximum enjoyment.
    bcpm livematch yield team000 venice

8. Remove the installed player. (removing the project folder is not enough!)

    bcpm uninstall yield
    
9. Create a new player from an existing template.

    bcpm copy myplayer git@git.pwnb.us:six370/yield.git

You'll need to import the project into Eclipse, and setup a git repository for the player.

10. If bcpm crashes or you abort it, you'll need to clean up the temporaries left behind.

    bcpm 

TESTING

The test cases are .rb (Ruby) files in the 'suite' directory. The following example showcases the
functionality available in a test suite. The suite DSL slightly resembles rspec.

    # Set the opponent for future matches.
    vs 'yield'
    
    # Set the map for future matches.
    map 'venice'
    
    # Disable energon draining.
    option 'bc.engine.upkeep', false
    
    # Replace a .java file in the player under test with a .java file in the test suite.
    # Both names are automatically prefixed with the team package ('yield.' in this case).
    replace_class 'RobotPlayer', 'test.players.TestRobotPlayer'
    
    # Re-route all calls that look like target.canMove(...) to
    # yield.test.LoggingStubs.canMoveStub(target, ...)
    stub_call 'canMove', 'test.LoggingStubs.canMoveStub'
    
    # Replace the code marked with Stubs.canMove.logo in yield.LoggingStubs with the code marked
    # Stubs.canMove.logoSource in yield.test.stubs.LoggingStubs
    replace_code 'LoggingStubs', 'Stubs.canMove.logo',
                 'test.stubs.LoggingStubs', 'Stubs.canMove.logoSource'
    
    # Run a test match to check some conditions.
    match do
      it 'must win in any way' do
        should_win
      end
    
      it "shouldn't leak exceptions" do
        should_not_throw
      end
      
      it 'should fail' do
        fail
      end
    end
    
    # Reset energon draining option to its default value.
    option 'bc.engine.upkeep', nil

To prevent infinite recursion, stubbing should be disabled in the actual stubs. The stub
implementation below demonstrates the syntax for stubbing and code replacement.

    package yield.test.stubs;
    
    import battlecode.common.Direction;
    import battlecode.common.RobotController;
    
    public class LoggingStubs {
      //$ -stubs
      public static final boolean canMoveStub(RobotController target, Direction where) {
        boolean returnValue = target.canMove(where);
        //$ +mark: Stubs.canMove.logo
        System.out.println("This should not show up");
        //$ -mark: Stubs.canMove.logo    
        System.out.println("canMove(" + where.toString() + ") -> " + returnValue);
        return returnValue;
      }
      //$ +stubs
    
      public static void markTest() {
        //$ +mark: Stubs.canMove.logoSource
        System.out.println("This should show up");
        //$ -mark: Stubs.canMove.logoSource
      }
    }

The code patching directives use very simple implementations based on file copying and regular
expressions. Following these best practices should help avoid broken builds:

  * Use Eclipse's "Organize imports" feature to achieve the item below:
  * Class names should be unqualified, and imports should use fully qualified names.
  * Use the same class name (but different package names) in replace_class.
  * A replace_class source class should only depend on classes in other packages.


INSTALLATION

On Ubuntu:
   
    sudo apt-get install ruby-full rubygems
    sudo gem install rubygems-update
    sudo `gem env | grep 'EXECUTABLE DIRECTORY' | ruby -e "puts gets.split(': ', 2).last"`/update_rubygems

On OSX:

    Get git from http://code.google.com/p/git-osx-installer/

On Windows 7+:

    Get git from http://code.google.com/p/msysgit/downloads/
    Get ruby 1.8.7 (add it to your path) from http://rubyinstaller.org/downloads/
    Get ant from http://code.google.com/p/winant/

On everything (skip the 'sudo' prefix on Windows though):

    sudo gem install rake echoe
    git clone git@git.pwnb.us:six370/bcpm.git
    cd bcpm
    rake install

You'll need an administrative shell on Windows.
